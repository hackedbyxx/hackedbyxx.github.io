

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/null">
  <link rel="icon" href="/image/findxx4.svg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="XXBlog">
  <meta name="author" content="XX">
  <meta name="keywords" content="">
  
  <title>retrofit的使用 - 寻找XX</title>

  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_3393780_0yzvgqoahfr.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"findxx.cn","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong><img width="40em" height="40em" src="/image/slogan.svg" srcset="/img/loading.gif" lazyload />&nbsp;&nbsp;寻找XX <strike>周杰伦</strike></strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/playlist/">
                <i class="iconfont icon-music"></i>
                歌单
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/image/0d5b857819f4b3bb068b9d7142c830bddca9f8427fd8d98dd8d93ffbf15e6374.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="retrofit的使用">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-10 11:14" pubdate>
        2022年5月10日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      82
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">retrofit的使用</h1>
            
            <div class="markdown-body">
              <p>Retrofit是squareup公司的开源力作，和同属squareup公司开源的OkHttp，一个负责网络调度，一个负责网络执行，为Android开发者提供了即方便又高效的网络访问框架。</p>
<p>不过，对于Retrofit这样设计精妙、代码简洁、使用方便的优秀开源项目，不能仅知道如何扩展和使用，或者仅研究它采用的技术或模式，“技”当然重要，但不能忽视了背后的“道”。</p>
<p>对于Retrofit，我们还应该看到的，是她在优化App架构方面的努力，以及她在提升开发效率方面的借鉴和启示。</p>
<p>本文试图通过一个具体场景，先总结Retrofit在架构中起到的作用，再分析其实现原理，最后探讨Retrofit给我们带来的启示。</p>
<p>我们先通过一个简单的应用场景来回顾Retrofit的使用过程。</p>
<h1 id="基本场景"><a href="#基本场景" class="headerlink" title="基本场景"></a>基本场景</h1><p>通常来说，使用Retrofit要经过这样几个步骤</p>
<ol>
<li><p>引用<br> 在gradle文件中引用retrofit</p>
<p> compile ‘com.squareup.retrofit2:retrofit:2.3.0’<br> compile ‘com.squareup.retrofit2:retrofit-converters:2.3.0’<br> compile ‘com.squareup.retrofit2:retrofit-adapters:2.3.0’</p>
</li>
</ol>
<p>如果需要使用更多扩展功能，比如gson转换，rxjava适配等，可以视自己需要继续添加引用</p>
<pre><code>compile &#39;com.squareup.retrofit2:converter-gson:2.3.0&#39;
compile &#39;com.squareup.retrofit2:adapter-rxjava2:2.3.0&#39;
</code></pre>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><br>如果现有的扩展包不能满足需要，还可以自己扩展<span class="hljs-selector-tag">converter</span>，<span class="hljs-selector-tag">adapter</span>等。<br><br><span class="hljs-number">1</span>.  定义接口<br>    <span class="hljs-selector-tag">Retrofit</span>要求定义一个网络请求的接口，接口函数里要定义<span class="hljs-selector-tag">url</span>路径、请求参数、返回类型。<br><br>```<span class="hljs-selector-tag">java</span><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">INetApiService</span> &#123;<br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;/demobiz/api.php&quot;</span>)<br>    Call&lt;BizEntity&gt; getBizInfo(<span class="hljs-variable">@Query</span>(<span class="hljs-string">&quot;id&quot;</span>) String id);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个接口定义中，用注解@GET(“/demobiz/api.php”)声明了url路径，用注解@Query(“id”) 声明了请求参数。<br>最重要的是，用Call<BizEntity>声明了返回值是一个Retrofit的Call对象，并且声明了这个对象处理的数据类型为BizEntity，BizEntity是我们自定义的数据模型。</BizEntity></p>
<ol>
<li>依次获得<strong>Retrofit对象、接口实例对象、网络工作对象</strong><br> 首先，需要新建一个retrofit对象。<br> 然后，根据上一步的接口，实现一个retrofit加工过的接口对象。<br> 最后，调用接口函数，得到一个可以执行网络访问的网络工作对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//新建一个Retrofit对象</span><br>Retrofit retrofit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>.baseUrl(Config.DOMAIN)<span class="hljs-comment">//要访问的网络地址域名，如http://www.zhihu.com</span><br>.addConverterFactory(GsonConverterFactory.create())<br>.build();<br>...<br><br><span class="hljs-comment">//用retrofit加工出对应的接口实例对象</span><br>INetApiService netApiService= retrofit.create(INetApiService.class);<br><span class="hljs-comment">//可以继续加工出其他接口实例对象</span><br>IOtherService otherService= retrofit.create(IOtherService.class);<br>···<br><br><span class="hljs-comment">//调用接口函数，获得网络工作对象</span><br>Call&lt;BizEntity&gt; callWorker= netApiService.getBizInfo(<span class="hljs-string">&quot;id001&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这个复杂的过程下来，最终得到的callWorker对象，才可以执行网络访问。</p>
<ol>
<li>访问网络数据<br> 用上一步获取的worker对象，执行网络请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">callWorker.enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>&lt;BizEntity&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(Call&lt;BizEntity&gt; call, Response&lt;BizEntity&gt; response)</span> &#123;...&#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Call&lt;BizEntity&gt; call, Throwable t)</span> &#123;...&#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<p>在回调函数里，取得我们需要的BizEntity数据对象。<br>网络访问结束。</p>
<h1 id="角色与作用"><a href="#角色与作用" class="headerlink" title="角色与作用"></a>角色与作用</h1><p>我们从上面的应用场景可以看出，Retrofit并不做网络请求，只是生成一个能做网络请求的对象。<br>Retrofit的作用是<strong>按照接口去定制Call网络工作对象</strong></p>
<p>什么意思？就是说：<br><strong>Retrofit不直接做网络请求<br>Retrofit不直接做网络请求<br>Retrofit不直接做网络请求</strong><br>重要的事情说三遍。</p>
<p>网络请求的目标虽然是数据，但是我们需要为这个数据写大量的配套代码，发起请求的对象Call，接收数据的对象CallBack，做数据转换的对象Converter，以及检查和处理异常的对象等。<br>这对于一个项目的开发、扩展和维护来说，都是成本和风险。</p>
<p>而Retrofit做的事情，就是为开发者节省这部分的工作量，Retrofit一方面从底层统一用OkHttp去做网络处理；另一方面在外层灵活提供能直接融入业务逻辑的Call网络访问对象。</p>
<p>具体来说，Retrofit只负责生产对象，生产能做网络请求的工作对象，他有点像一个工厂，只提供产品，工厂本身不处理网络请求，产品才能处理网络请求。<br>Retrofit在网络请求中的作用大概可以这样理解：</p>
<p><img src="/2022/05/10/retrofit/35dfaaa7.png" srcset="/img/loading.gif" lazyload></p>
<p> Retrofit的作用</p>
<p>我们看到，从一开始，Retrofit要提供的就是个Call工作对象。<br>换句话说，对于给Retrofit提供的那个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">INetApiService</span> &#123;<br>    <span class="hljs-meta">@GET(&quot;/demobiz/api.php&quot;)</span><br>    Call&lt;BizEntity&gt; <span class="hljs-title function_">getBizInfo</span><span class="hljs-params">(<span class="hljs-meta">@Query(&quot;id&quot;)</span> String id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个接口并不是传统意义上的网络请求接口，这个接口不是用来获取数据的接口，而是用来生产对象的接口，<strong>这个接口相当于一个工厂，接口中每个函数的返回值不是网络数据，而是一个能进行网络请求的工作对象，我们要先调用函数获得工作对象，再用这个工作对象去请求网络数据。</strong></p>
<p>所以Retrofit的实用价值意义在于，他能根据你的接口定义，灵活地生成对应的网络工作对象，然后你再择机去调用这个对象访问网络。<br>理解了这一点，我们才能去扩展Retrofit，并理解Retrofit的设计思想。</p>
<h1 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h1><p>我们先来看Retrofit能扩展哪些功能，然后再去理解Retrofit的工作原理。<br>Retrofit主要可以扩展三个地方：</p>
<ol>
<li>OkHttpClient<br> Retrofit使用OkHttpClient来实现网络请求，这个OkHttpClient虽然不能替换为其他的网络执行框架比如Volley，但是Retrofit允许我们使用自己扩展OkHttpClient，一般最常扩展的就是Interceptor拦截器了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">mClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>                .addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> chain.request().newBuilder();<br>                            builder.addHeader(<span class="hljs-string">&quot;Accept-Charset&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                            builder.addHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot; application/json&quot;</span>);<br>                            builder.addHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>                            <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> builder.build();<br>                            <span class="hljs-keyword">return</span> chain.proceed(request);<br>                        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;).build();<br><br><span class="hljs-type">Retrofit</span> <span class="hljs-variable">retrofit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>                .baseUrl(Config.DOMAIN)<br>                .addConverterFactory(GsonConverterFactory.create())<br>                .client(mClient)<br>                .build();<br></code></pre></td></tr></table></figure>

<ol>
<li> addConverterFactory</li>
</ol>
<p>扩展的是对返回的数据类型的自动转换，把一种数据对象转换为另一种数据对象。<br>在上述场景中，GsonConverterFactory可以把Http访问得到的json字符串转换为Java数据对象BizEntity，这个BizEntity是在INetApiService接口中要求的的。<br>这种转换我们自己也经常做，很好理解。<br>如果现有的扩展包不能满足需要，可以继承Retrofit的接口。retrofit2.Converter&lt;F,T&gt;，自己实现Converter和ConverterFactory。<br>在创建Retrofit对象时，可以插入我们自定义的ConverterFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//retrofit对象</span><br>Retrofit retrofit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>.baseUrl(Config.DOMAIN)<br>.addConverterFactory(GsonConverterFactory.create())<br>.addConverterFactory(YourConverterFactory.create())<span class="hljs-comment">//添加自定义Converter</span><br>.build();<br></code></pre></td></tr></table></figure>

<ol>
<li> addCallAdapterFactory</li>
</ol>
<p>扩展的是对网络工作对象callWorker的自动转换，把Retrofit中执行网络请求的Call对象，转换为接口中定义的Call对象。<br>这个转换不太好理解，我们可以对照下图来理解：</p>
<p><img src="/2022/05/10/retrofit/d496aeae.png" srcset="/img/loading.gif" lazyload></p>
<p> callAdapter转换Call对象</p>
<p>Retrofit本身用一个OkHttpCall的类负责处理网络请求，而我们在接口中定义需要定义很多种Call，例如Call<BizEntity>，或者Flowable<BizEntity>等，接口里的Call和Retrofit里的OkHttpCall并不一致，所以我们需要用一个CallAdapter去做一个适配转换。<br>（Retrofit底层虽然使用了OkHttpClient去处理网络请求，但她并没有使用okhttp3.call这个Call接口，而是自己又建了一个retrofit2.Call接口，OkHttpCall继承的是retrofit2.Call，与okhttp3.call只是引用关系。<br>这样的设计符合依赖倒置原则，可以尽可能的与OkHttpClient解耦。）</BizEntity></BizEntity></p>
<p>这其实是Retrofit非常核心，也非常好用的一个设计，如果我们在接口中要求的函数返回值是个RxJava的Flowable对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">INetApiService</span> &#123;<br>    <span class="hljs-meta">@GET(&quot;/demobiz/api.php&quot;)</span><br>    Flowable&lt;BizEntity&gt; <span class="hljs-title function_">getBizInfo</span><span class="hljs-params">(<span class="hljs-meta">@Query(&quot;id&quot;)</span> String id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们只需要为Retrofit添加对应的扩展</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//retrofit对象</span><br>Retrofit retrofit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>.baseUrl(Config.DOMAIN)<br>.addConverterFactory(GsonConverterFactory.create())<br>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())<br>.build();<br></code></pre></td></tr></table></figure>

<p>就能得到Flowable类型的callWorker对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用retrofit加工出对应的接口实例对象</span><br>INetApiService netApiService= retrofit.create(INetApiService.class);<br>···<br><span class="hljs-comment">//调用接口函数，获得网络工作对象</span><br>Flowable&lt;BizEntity&gt; callWorker= netApiService.getBizInfo(<span class="hljs-string">&quot;id001&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在这里，callAdapter做的事情就是把retrofit2.Call对象适配转换为Flowable<T>对象。<br>同样，如果现有的扩展包不能满足需要，可以继承Retrofit的接口retrofit2.CallAdapter&lt;R,T&gt;，自己实现CallAdapter和CallAdapterFactory。</T></p>
<h1 id="Retrofit实现原理"><a href="#Retrofit实现原理" class="headerlink" title="Retrofit实现原理"></a>Retrofit实现原理</h1><p>Retrofit固然设计精妙，代码简洁，使用方便，但相应的，我们要理解Retrofit的实现原理也不太容易，这么精妙的设计是极佳的研究素材，我们不能仅仅停留在知道怎么使用，怎么扩展的阶段，那实在是对这个优秀开源项目的浪费。<br>其实，Retrofit使用的，就是动态代理，方法注解、建造者和适配器等成熟的技术或模式，但是由于她的设计紧凑，而且动态代理屏蔽了很多过程上的细节，所以比较难以理解。</p>
<h1 id="Retrofit实现原理——从动态代理开始"><a href="#Retrofit实现原理——从动态代理开始" class="headerlink" title="Retrofit实现原理——从动态代理开始"></a>Retrofit实现原理——从动态代理开始</h1><p>从前面的使用场景可知，retrofit会生成一个接口实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用retrofit加工出对应的接口实例对象</span><br>INetApiService netApiService= retrofit.create(INetApiService.class);<br></code></pre></td></tr></table></figure>


<p>到Retrofit源码里看create函数，是一个动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; service &#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            ...<br>            ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);<br>            OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);<br>            <span class="hljs-keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);<br>          &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>要理解动态代理，最好要看到动态生成的代理类。</p>
<p>由于动态代理是在运行时动态生成的代理类，用常规的反编译方法无法查看，一般要使用Java提供的sun.misc.ProxyGenerator.generateProxyClass(String proxyName,class[] interfaces)函数生成代理类，函数会返回byte[]字节码，然后对字节码反编译得到Java代码。<br>有一个小问题是，AndroidStudio并不提供sun.misc这个包，我们需要用IntelliJ或者Eclipse建立一个Java工程，在Java环境里调用这个函数。</p>
<p>拿到的代理类，大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">INetApiService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">INetApiService</span> &#123;<br>  ...<span class="hljs-comment">//一些Object自带方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<span class="hljs-comment">//接口定义的方法</span><br>  <span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//Object自带方法的初始化</span><br>      m0,m1,m2 = ...<br>      <span class="hljs-comment">//接口中定义的方法</span><br>      m3 = Class.forName(<span class="hljs-string">&quot;com.demo.net$INetApiService&quot;</span>)<span class="hljs-comment">//反射接口类</span><br>          .getMethod(<span class="hljs-string">&quot;getBizInfo&quot;</span>,<span class="hljs-comment">//反射函数</span><br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>) &#125;);<span class="hljs-comment">//反射参数</span><br>      <span class="hljs-comment">//接口中定义的其他方法</span><br>      ...<br>    &#125; <br>    ...<br>  &#125;<br><span class="hljs-comment">//返回接口实例对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">INetApiService</span> <span class="hljs-params">(InvocationHandler invocationHandler)</span>&#123;<br>  <span class="hljs-built_in">super</span>(invocationHandler);<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Call <span class="hljs-title function_">getBizInfo</span><span class="hljs-params">(String str)</span>&#123;<br>  ...<br>  <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//用Handler去调用</span><br>    <span class="hljs-keyword">return</span> (Call)<span class="hljs-built_in">this</span>.h.invoke(<span class="hljs-built_in">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;str&#125;);<br>  &#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以看到，代理类生成的是一个INetApiService接口的实例对象，该对象的getBizInfo函数返回的是接口中定义的Call网络工作对象，这也体现了Retrofit的核心价值，生成接口定义的Call网络工作对象。</p>
<p>那么，这个Call网络工作对象是如何生成的呢，上面动态代理生成的代码是这样的：</p>
<pre><code>return (Call)this.h.invoke(this, m3, new Object[]&#123;str&#125;);
</code></pre>
<p>也就是说，这个Call网络工作对象是在InvocationHandler中实现的，也就是在Retrofit.create函数中，由InvocationHandler实现的。</p>
<p>这样我们就明白了，<strong>Retrofit使用动态代理，其实是为了开发者在写代码时方便调用，而真正负责生产Call网络工作对象的，还是Retrofit.create函数中定义的这个InvocationHandler</strong>，这个InvocationHandler的代码我们再贴一遍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>    ...<br>    ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>        (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);<br>    OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(serviceMethod, args);<br>    <span class="hljs-keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ServiceMethod能让我们准确解析到INetApiService中定义的函数，为最后的适配转换提供转换目标，详细分析我们后面再说，先看适配转换的过程。</p>
<p>我们看到，Retrofit内部默认使用OkHttpCall对象去处理网络请求，但是返回的网络工作对象是经过适配器转换的，转换成接口定义的那种Call网络工作对象。</p>
<p>这个适配转换，就是Retrofit能按照接口去定制Call网络工作对象的秘密。</p>
<h1 id="Retrofit实现原理——适配转换Call对象"><a href="#Retrofit实现原理——适配转换Call对象" class="headerlink" title="Retrofit实现原理——适配转换Call对象"></a>Retrofit实现原理——适配转换Call对象</h1><p>我们在初始化Retrofit对象时，好像不添加CallAdapterFactory也能实现适配转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//retrofit对象</span><br>Retrofit retrofit=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>.baseUrl(Config.DOMAIN)<br>.addConverterFactory(GsonConverterFactory.create())<br><span class="hljs-comment">//可以不添加CallAdapterFactory</span><br>.build();<br></code></pre></td></tr></table></figure>

<p>这是怎么回事呢，我们知道Retrofit使用了建造者模式，建造者模式的特定就是实现了建造和使用的分离，所以建造者模式的建造函数里，一般会有很复杂的对象创建和初始化过程，所以我们要看一下Retrofit的build函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Retrofit <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      ...<br>      okhttp3.Call.<span class="hljs-type">Factory</span> <span class="hljs-variable">callFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.callFactory;<br>      <span class="hljs-keyword">if</span> (callFactory == <span class="hljs-literal">null</span>) &#123;<br>        callFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<span class="hljs-comment">//使用OkHttpClient处理网络请求</span><br>      &#125;<br>      ...<br>      <span class="hljs-comment">//根据当前运行平台，设置默认的callAdapterFactory</span><br>      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));<br>      ...<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>(callFactory, baseUrl, converterFactories, adapterFactories,<br>          callbackExecutor, validateEagerly);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这段代码里，我们看到Retrofit使用OkHttpClient处理网络请求，并且会添加默认的callAdapterFactory，这个platform是一个简单工厂，能根据当前系统平台去生成对应的callAdapterFactory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Platform <span class="hljs-title function_">findPlatform</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Class.forName(<span class="hljs-string">&quot;android.os.Build&quot;</span>);<br>      <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Android</span>();<span class="hljs-comment">//根据当前系统平台返回相应的对象</span><br>      &#125;<br>    ...<br>  &#125;<br>  ...<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Android</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Platform</span> &#123;<br>    ...<br>    <span class="hljs-meta">@Override</span> CallAdapter.Factory <span class="hljs-title function_">defaultCallAdapterFactory</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Executor callbackExecutor)</span> &#123;<br>      <span class="hljs-keyword">if</span> (callbackExecutor == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCallAdapterFactory</span>(callbackExecutor);<br>    &#125;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这个Platform是Retrofit在Builder的构造函数里初始化的。</p>
<p>所以，在Retrofit.build()函数中，我们为Retrofit默认添加的callAdapterFactory，是在Platform中为Android系统设定的ExecutorCallAdapterFactory。<br>我们看ExecutorCallAdapterFactory的代码，这是一个工厂类，可以返回CallAdapter对象：</p>
<p>  <code class="  language-tsx">@Override<br>  public CallAdapter<?, ?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;<br>    ...<br>    return new CallAdapter<Object, call<?>>() &#123;<br>      ...<br>      //               转换后              转换前，也就是OkHttpCall<br>      @Override public Call<Object> adapt(Call<Object> call) &#123;<br>        return new ExecutorCallbackCall<>(callbackExecutor, call);<br>      &#125;<br>    &#125;;<br>  &#125;</Object></Object></Object,></code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br>在adapt函数中，适配器会把<span class="hljs-type">Retrofit中用来访问网络的OkHttpCall，转换为一个ExecutorCallbackCall</span>(继承了<span class="hljs-type">INetApiService接口里要求返回的网络工作对象retrofit2</span>.<span class="hljs-type">Call</span>)，<br>这个例子里面，由于<span class="hljs-type">OkHttpCall和ExecutorCallbackCall都实现了retrofit2</span>.<span class="hljs-type">Call接口，结果出现了从Call</span>&lt;<span class="hljs-type">Object</span>&gt;转换为<span class="hljs-type">Call</span>&lt;<span class="hljs-type">Object</span>&gt;的情况，这可能不容易理解，我们换个<span class="hljs-type">RxJava2CallAdapterFactory来看看</span><br><br>```java<br><span class="hljs-comment">//RxJava2CallAdapterFactory中</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">CallAdapter</span>&lt;?, ?&gt; <span class="hljs-keyword">get</span>(<span class="hljs-type">Type</span> returnType, <span class="hljs-type">Annotation</span>[] annotations, <span class="hljs-type">Retrofit</span> retrofit) &#123;<br>    <span class="hljs-operator">...</span><br>    <span class="hljs-keyword">return</span> new <span class="hljs-type">RxJava2CallAdapter</span>(responseType, scheduler, isAsync, isResult, isBody, isFlowable,<br>        isSingle, isMaybe, <span class="hljs-literal">false</span>);<br>&#125;<br>  <span class="hljs-comment">//RxJava2CallAdapter中</span><br>  <span class="hljs-comment">//               转换后        转换前，也就是OkHttpCall</span><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">Object</span> adapt(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">R</span>&gt; call) &#123;<br>   <span class="hljs-operator">...</span><br>   <span class="hljs-type">Observable</span>&lt;?&gt; observable;<br>   <span class="hljs-operator">...</span><br>   <span class="hljs-keyword">return</span> observable;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这个CallAdapter的转换就比较明显了，把retrofit2.Call对象通过适配器转换为了一个实为Observable&lt;?&gt;的Object对象。</p>
<p>至此，我们可以理解Retrofit根据接口定义动态生产Call网络请求工作对象的原理了，其实就是通过适配器把retrofit2.Call对象转换为目标对象。</p>
<p>至于适配器转换过程中，如何实现的对象转换，就可以根据需求来自由实现了，比如利用静态代理等，如有必要，我们可以自行开发扩展，Retrofit框架并不限制我们对于适配器的实现方式。</p>
<h1 id="Retrofit实现原理——函数解析、网络请求和数据转换"><a href="#Retrofit实现原理——函数解析、网络请求和数据转换" class="headerlink" title="Retrofit实现原理——函数解析、网络请求和数据转换"></a>Retrofit实现原理——函数解析、网络请求和数据转换</h1><p>在前面分析中，我们知道了Retrofit的整体工作流程，就是Retrofit用动态代理生成Call网络请求对象，在这个过程中，用适配器把Retrofit底层的retrofit2.Call对象转换为INetApiService中定义的Call网络请求对象（如Flowable）。</p>
<p>问题是，Retrofit具体是如何知道了INetApiService中定义的Call网络请求对象，如何实现网络请求，以及如何执行的数据转换呢？</p>
<p>具体过程如下；<br>首先，根据INetApiService中定义的函数，解析函数，得到函数的具体定义，并生成对应的ServiceMethod。<br>然后，根据这个ServiceMethod，实现一个OkHttpCall的Call对象，负责在Retrofit底层实现网络访问。<br>其中，在网络访问返回了网络数据时，根据ServiceMethod实现数据转换。<br>最后，利用上一小节中匹配的适配器，把OkHttpCall对象转换为INetApiService要求的Call网络请求对象。</p>
<p>所以，我们要了解的就是函数解析、网络请求和数据转换这三个动作，至于最后的适配转换，在上一节中已经分析过了。</p>
<p><strong>1. 函数解析</strong><br>在接口函数里，用注解描述了输入参数，用Java对象定义了返回值类型，所以对输入参数和返回值，ServiceMethod采取了不同的方式去处理。<br><strong>输入参数</strong><br>输入参数是用来描述url的，它的处理相对简单，ServiceMethod会根据反射得到的Method，取得Annotation注解信息，这些注解是Retrofit自己预定义好的（retrofit2.http.*），ServiceMethod根据预先的定义，直接判断注解所属的逻辑分支，在有网络请求时分情况进行处理，就能得到目标url，http请求头等数据。<br><strong>返回值</strong><br>返回值是需要用CallAdapter去适配的，所以核心在于生成对应的CallAdapter。<br>在Retrofit生成Call网络工作对象时，她通过动态代理获取到了接口函数的Method定义，从这个Method中可以获取函数定义的返回对象类型，由于这个转换是需要CallAdapterFactory生产CallAdapter对象去实现，而Retrofit事先并不知道要使用哪个Factory，所以她是遍历所有的CallAdapterFactory，根据目标函数的返回值类型，让每个Factory都去尝试生产一个CallAdapter，哪个成功就用哪个。</p>
<p><strong>2. 网络请求</strong><br>OkHttpCall继承的retrofit2.Call接口是为了依赖倒置解耦的，真正的网络请求是由OkHttpCall内部引用的okhttp3.call处理的，这个okhttp3.call是<br>借道ServiceMethod获取的Retrofit中的callFactory，也就是Retrofit中的OkHttpClient。</p>
<p>整个引用链条是这样的：<br>OkHttpCall–okhttp3.call<br>–&gt;<br>ServiceMethod–callFactory<br>–&gt;<br>Retrofit.build()–callFactory//**(如未扩展赋值)<strong>new OkHttpClient();<br>–&gt;<br>Retrofit.Builder().client(mClient)//</strong>(可能有扩展赋值)**扩展过的OkHttpClient</p>
<p>最终的网络请求是由OkHttpCall调用OkHttpClient发出的，调用和回调等过程，也就是在OkHttpCall中处理的。</p>
<p>网络请求的生成过程中，为了使用接口函数中定义的参数，OkHttpCall会调用ServiceMethod来生成Request请求对象，再交给OkHttpCall去处理。</p>
<p><strong>3. 数据转换</strong><br>因为回调是在OkHttpCall中处理的，所以对回调数据的转换也在OkHttpCall中触发，为了符合接口函数中定义的返回数据类型，OkHttpCall会调用ServiceMethod来转换Response返回数据对象。</p>
<p>OkHttpCall对返回的网络数据，会调用一个serviceMethod.toResponse(ResponseBody body)函数，函数中执行的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">R <span class="hljs-title function_">toResponse</span><span class="hljs-params">(ResponseBody body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> responseConverter.convert(body);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这个函数可以把原始的okhttp3. ResponseBody数据转换为INetApiService接口中要求的数据类型（如BizEntity类型）。<br>从代码可以看出，实现数据转换的核心对象其实是responseConverter，这个Converter实际上要依次经过Retrofit的建造和ServiceMethod的建造后，才能确定下来的。</p>
<p><strong>Retrofit建造时添加数据转换工厂</strong><br>Retrofit里有converterFactries列表，这是在我们初始化Retrofit实例时添加的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//retrofit对象</span><br><span class="hljs-type">Retrofit</span> <span class="hljs-variable">retrofit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>.Builder()<br>    .baseUrl(Config.DOMAIN)<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .addConverterFactory(YourConverterFactory.create())<span class="hljs-comment">//添加自定义Converter</span><br>    .build();<br></code></pre></td></tr></table></figure>

<p><strong>ServiceMethod建造时设定数据转换器</strong><br>ServiceMethod在建造时，就已经确定了对应的是INetApiService中的哪个函数，所以需要明确设定自己的Converter&lt;R,T&gt;转换对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>      ...<br>      responseConverter = createResponseConverter();<br>      ...<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>这需要调用Retrofit</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="hljs-title function_">createResponseConverter</span><span class="hljs-params">()</span> &#123;<br>      ...<br>      retrofit.responseBodyConverter(responseType, annotations);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Retrofit会在自己的转换器工厂列表中遍历每个ConverterFactory，尝试根据ServiceMethod所对应的目标数据类型，找到Converter数据转换类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start, count = converterFactories.size(); i &lt; count; i++) &#123;<br>      Converter&lt;ResponseBody, ?&gt; converter =<br>          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="hljs-built_in">this</span>);<br>      <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//noinspection unchecked</span><br>        <span class="hljs-keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>以Gson转换为例，GsonConverterFactory会通过getAdapter来尝试匹配目标数据类型：</p>
<pre><code>public &lt;T&gt; TypeAdapter&lt;T&gt; getAdapter(TypeToken&lt;T&gt; type) &#123;...&#125;
</code></pre>
<p>如果可以匹配，那么前面调用serviceMethod.toResponse(ResponseBody body)函数时，会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">R <span class="hljs-title function_">toResponse</span><span class="hljs-params">(ResponseBody body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> responseConverter.convert(body);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用这段代码时，其实就是调用了Gson中最终执行数据转换的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> T <span class="hljs-title function_">convert</span><span class="hljs-params">(ResponseBody value)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">JsonReader</span> <span class="hljs-variable">jsonReader</span> <span class="hljs-operator">=</span> gson.newJsonReader(value.charStream());<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">return</span> adapter.read(jsonReader);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      value.close();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>总结来说，Retrofit在类的单一职责方面分隔的很好，OkHttpCall类只负责网络交互，凡是需要知道函数定义的，都交给ServiceMethod类去处理，而ServiceMethod类对使用者不公开，因为Retrofit是个外观模式，而所有需要扩展的都在Retrofit的建造者中实现，他们的分工大概是这样的：</p>
<p><img src="/2022/05/10/retrofit/25f4d8a2.png" srcset="/img/loading.gif" lazyload></p>
<p> 三个类的分工</p>
<p>这三个类分工合作，共同实现了函数解析、网络访问和数据转换，并保留了良好的可扩展性。</p>
<h1 id="Retrofit实现原理——整体结构与分工实现"><a href="#Retrofit实现原理——整体结构与分工实现" class="headerlink" title="Retrofit实现原理——整体结构与分工实现"></a>Retrofit实现原理——整体结构与分工实现</h1><p>至此，Retrofit的实现细节就已经基本清楚了，他用动态代理去定制接口定义的Call网络工作对象，用适配器去把底层的Call对象转换为目标Call对象，用函数解析/OkHttpClient/数据转换等实现对Call对象的适配转换，并能处理真正的网络请求。<br>这里面涉及的整体结构和角色分工，大概可以这样表示：</p>
<p><img src="/2022/05/10/retrofit/951b3a66.png" srcset="/img/loading.gif" lazyload></p>
<p> 整体结构与角色分工</p>
<p>其中，扩展适配器、扩展数据转换和扩展OkHttpClient，虽然都是通过Retrofit实现扩展，但真正的使用者是Retrofit内部的ServiceMethod、OkHttpCall和okhttp3.call等类或对象。</p>
<h1 id="反推Retrofit的设计过程"><a href="#反推Retrofit的设计过程" class="headerlink" title="反推Retrofit的设计过程"></a>反推Retrofit的设计过程</h1><p>如果我们不直接正面分析Retrofit的结构设计和技术细节，而是先从Retrofit的功能和作用入手，倒过来推测Retrofit的目标，进而分析其架构和搭建细节，Retrofit为什么会设计成这样就很好理解了。</p>
<p>Retrofit的功能是<strong>按照接口定义，自动定制Call网络工作对象</strong>，所以Retrofit的目标应该就是避免为网络访问开发大量的配套代码。</p>
<p>为了实现这一目标，Retrofit需要分析哪些是易变的，哪些是不变的，然后分别处理。</p>
<p>由于Retrofit提供网络访问的工作对象，又是服务于具体业务，所以可以分网络访问和具体业务两部分来分析。</p>
<p><strong>网络访问的不变性</strong><br>对于网络访问来说，不变的是一定有一个实现网络访问的对象，Retrofit选用了自家的OkHttpClient，不过为了把Retrofit和OkHttp两个项目解耦合，Retrofit根据依赖倒置原则，定义了Retrofit自己的Call即<strong>retrofit2.call</strong>，并定义了操作网络请求的<strong>OkHttpCall</strong>。</p>
<p><strong>网络访问的易变性</strong><br>对于网络访问来说，易变的是网络访问的url、请求方式（get/post等）、Http请求的Header设置与安全设置等，以及返回的数据类型。</p>
<p>针对易变的url和请求方式，Retrofit使用了<strong>方法注解</strong>的方式，可读性良好，扩展性优异，但这需要实现对接口函数中注解的解析，这样就有了<strong>ServiceMethod</strong>。<br>针对Http请求的各种设置，其实Retrofit没做什么，因为Retrofit使用的OkHttp有<strong>拦截器</strong>机制，可以应付这种变化。<br>针对返回的数据类型，由于目标数据类型与业务有关，是不确定的，Retrofit无法提供一个万能的转换类，所以Retrofit提供了扩展接口，允许开发者自己定义<strong>ConverterFactory和Converter</strong>，去实现潜在的数据类型转换。</p>
<p><strong>具体业务的不变性</strong><br>对于具体业务来说，不变的是一定要有一个Call网络工作对象，所以Retrofit可以有一个生产对象的机制（像工厂一样）</p>
<p><strong>具体业务的易变性</strong><br>对于具体业务来说，易变的就是这个Call网络工作对象的类型，不仅有CallBacl回调、可能还有Flowable工作流、或者其他潜在的对象类型。</p>
<p>针对这种Call对象的易变性，Retrofit也是无法提供一个万能的实现类，所以也是提供了扩展解耦，允许开发者自己定义<strong>CallAdapterFactory和CallAdapter</strong>，去实现潜在的Call类型转换。</p>
<p>因为这种Call对象的生产需要有大量的配套代码，为了简化代码，Retrofit使用<strong>动态代理</strong>来生产这个对象。</p>
<p>最后，因为需要处理的方法和对象太多太复杂，需要使用<strong>建造者模式</strong>来把建造过程和使用过程分离开。</p>
<p>这样倒着走一遍之后，我们再看Retrofit的设计和实现原理，就会觉得水到渠成，对于Retrofit精妙的设计更会有一种切身体会。</p>
<h1 id="借鉴与启示"><a href="#借鉴与启示" class="headerlink" title="借鉴与启示"></a>借鉴与启示</h1><p>在上文的反推过程中，我们可窥见（瞎猜）Jake大神的一些思路：</p>
<ol>
<li>万物皆对象<br> 网络访问后，回调数据是个对象；网络访问本身也是个对象。</li>
<li>依赖倒置<br> 哪怕是使用自家的OkHttp，哪怕底层调用的始终是OkHttpClient，也需要依赖一个抽象的retrofit2.Call接口，依赖于抽象，而不是依赖于具体。</li>
<li>单一职责<br> 类的职责需要维持单一，流程需要但是超出自己职责的功能，去调用相关的类实现，比如OkHttpClient和ServiceMethod的各自职责与调用关系。</li>
<li>迪米特法则<br> 内部实现再复杂，对于外部调用者也只展示他需要的那些功能，例如Retrofit。</li>
<li>自动&gt;人工<br> 动态代理的使用，可以用自动生成的模板代码，减轻人工编写配套代码的工作量，成本更低，风险更低。</li>
<li>利用工厂类开放扩展<br> 对于流程确定，但方法不能确定的，利用工厂类，对调用者开放扩展能力。</li>
<li>利用多个工厂类组成扩展列表<br> 如果1个工厂类不能实现兼得，何不设置一个工厂类列表，在多个工厂类中，看哪个工厂类能解决问题。</li>
<li>利用建造者模式把建造和使用分离<br> 这样使用者不需要关系复杂的建造过程，例如Retrofit和ServiceMethod。</li>
<li>利用外观模式减少对复杂子系统的操作<br> 虽然有复杂的子系统协同工作，调用者只需要调用最外层的Retrofit即可。</li>
<li>其他<br>开放封闭、接口隔离、里式替换、静态代理等设计原则或设计模式都有体现也都很熟悉了，就不再啰嗦。</li>
</ol>
<p>最后感叹一下。</p>
<p>对于网络访问的抽象与优化，实际上是个非常难的课题，在Retrofit之前，大家努力的方向基本上都是Volley/OkHttp这种围绕底层网络访问的工作。<br>因为越底层的东西越容易抽象，越上升到接近业务层，就越容易在纷扰的业务层中迷失。<br>Retrofit能精准地抓到Call网络工作对象这个关键点，并能通过一系列精巧的设计实现对这种类型“飘忽不定”的对象的自动化定制生产，着实令人赞叹。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">Retrofit</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/308f3c54abdd">你真的会用Retrofit2吗?Retrofit2完全教程</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1a3a881a144">Retrofit2 源码解析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3b5ef96d1a09">Retrofit 框架源码学习</a><br><a target="_blank" rel="noopener" href="https://blog.piasy.com/2016/06/25/Understand-Retrofit/">拆轮子系列：拆 Retrofit</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/self_study/article/details/55050627">Android 动态代理以及利用动态代理实现 ServiceHook</a></p>
<p>作者：蓝灰_q<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f57b7cdb1c99">https://www.jianshu.com/p/f57b7cdb1c99</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/retrofit/">retrofit</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/retrofit/">retrofit</a>
                    
                      <a class="hover-with-bg" href="/tags/OkHttp/">OkHttp</a>
                    
                      <a class="hover-with-bg" href="/tags/squareup/">squareup</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/11/RxJava/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">RxJava的使用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/06/24/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createScript('https://fastly.jsdelivr.net/npm/@waline/client@1.2.2/dist/Waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comment.findxx.cn/","placeholder":"说点什么","path":"window.location.pathname","avatar":"wavatar","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":true,"avatarCDN":"https://sdn.geekzu.org/avatar/","avatarForce":false,"requiredFields":[],"emoji":["https://fastly.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq","https://fastly.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://fastly.jsdelivr.net/gh/walinejs/emojis@1.0.0/weibo","https://fastly.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili"],"emojiCDN":null,"emojiMaps":null,"anonymous":null},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        new Waline(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://fastly.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://fastly.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://fastly.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://fastly.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://fastly.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://fastly.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://fastly.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
